// GO대로 - AR Photo Guide App
// Perfect Frame Implementation

class MomentieApp {
    constructor() {
        // DOM Elements
        this.screens = {
            splash: document.getElementById('splash-screen'),
            camera: document.getElementById('camera-screen'),
            preview: document.getElementById('preview-screen'),
            gallery: document.getElementById('gallery-screen')
        };

        this.elements = {
            video: document.getElementById('camera-feed'),
            overlayCanvas: document.getElementById('overlay-canvas'),
            poseCanvas: document.getElementById('pose-canvas'),
            guideFrame: document.getElementById('guide-frame'),
            guideSilhouette: document.querySelector('.guide-silhouette'),
            alignmentFeedback: document.getElementById('alignment-feedback'),
            feedbackText: document.querySelector('.feedback-text'),
            timerCountdown: document.getElementById('timer-countdown'),
            countdownNumber: document.querySelector('.countdown-number'),
            previewImage: document.getElementById('preview-image'),
            galleryGrid: document.getElementById('gallery-grid'),
            galleryEmpty: document.getElementById('gallery-empty'),
            galleryPreview: document.querySelector('.gallery-preview'),
            settingsPanel: document.getElementById('settings-panel'),
            gridOverlay: document.getElementById('grid-overlay'),
            levelIndicator: document.getElementById('level-indicator'),
            levelBubble: document.querySelector('.level-bubble'),
            ratioPanel: document.getElementById('ratio-panel'),
            ratioMask: document.getElementById('ratio-mask'),
            ratioLabel: document.querySelector('.ratio-label'),
            flashBtn: document.getElementById('flash-btn'),
            flashIconOff: document.querySelector('.flash-icon-off'),
            flashIconOn: document.querySelector('.flash-icon-on'),
            editGuideBtn: document.getElementById('edit-guide-btn'),
            guideEditToolbar: document.getElementById('guide-edit-toolbar'),
            resizeHandles: document.querySelectorAll('.resize-handle'),
            shootIndicator: document.getElementById('shoot-indicator'),
            captureBtn: document.getElementById('capture-btn')
        };

        // State
        this.state = {
            currentScreen: 'splash',
            cameraFacing: 'environment',
            currentGuide: 'none',
            currentRatio: '3:4',
            timerDuration: 0,
            isCapturing: false,
            flashEnabled: false,
            flashSupported: false,
            poseDetectionEnabled: true,
            gridEnabled: false,
            levelEnabled: false,
            soundEnabled: true,
            photos: [],
            stream: null,
            videoTrack: null,
            pose: null,
            deviceOrientation: { alpha: 0, beta: 0, gamma: 0 },
            ratioPanelOpen: false,
            // Guide edit state
            guideEditMode: false,
            guidePosition: { x: 50, y: 50 }, // percentage
            guideScale: 1,
            isDragging: false,
            isResizing: false,
            dragStart: { x: 0, y: 0 },
            // Saved guide positions per type
            savedGuidePositions: {
                portrait: { x: 50, y: 50, scale: 1 },
                couple: { x: 50, y: 50, scale: 1 },
                group: { x: 50, y: 50, scale: 1 }
            }
        };

        // Ratio definitions
        this.ratios = {
            '1:1': { width: 1, height: 1 },
            '3:4': { width: 3, height: 4 },
            '9:16': { width: 9, height: 16 },
            'full': { width: 0, height: 0 }
        };

        // Default guide sizes
        this.defaultGuideSizes = {
            portrait: { width: 140, height: 280 },
            couple: { width: 240, height: 280 },
            group: { width: 310, height: 240 }
        };

        // Contexts
        this.overlayCtx = this.elements.overlayCanvas.getContext('2d');
        this.poseCtx = this.elements.poseCanvas.getContext('2d');

        // Initialize
        this.init();
    }

    init() {
        this.bindEvents();
        this.loadPhotosFromStorage();
        this.loadGuidePositions();
        this.updateGalleryPreview();
        this.setRatio('3:4');
        this.handleOrientationChange();
    }

    bindEvents() {
        // Start button
        document.getElementById('start-btn').addEventListener('click', () => {
            this.showScreen('camera');
            this.startCamera();
        });

        // Close buttons
        document.getElementById('close-btn').addEventListener('click', () => {
            this.stopCamera();
            this.showScreen('splash');
        });

        document.getElementById('preview-close-btn').addEventListener('click', () => {
            this.showScreen('camera');
        });

        document.getElementById('gallery-close-btn').addEventListener('click', () => {
            this.showScreen('camera');
        });

        // Camera controls
        document.getElementById('capture-btn').addEventListener('click', () => {
            if (!this.state.guideEditMode) {
                this.capturePhoto();
            }
        });

        document.getElementById('switch-camera-btn').addEventListener('click', () => {
            this.switchCamera();
        });

        document.getElementById('flash-btn').addEventListener('click', () => {
            this.toggleFlash();
        });

        // Ratio button
        document.getElementById('ratio-btn').addEventListener('click', () => {
            this.toggleRatioPanel();
        });

        // Ratio selection
        document.querySelectorAll('.ratio-option').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const ratio = e.currentTarget.dataset.ratio;
                this.setRatio(ratio);
                this.toggleRatioPanel(false);
            });
        });

        // Gallery
        document.getElementById('gallery-btn').addEventListener('click', () => {
            this.showScreen('gallery');
            this.renderGallery();
        });

        // Settings
        document.getElementById('settings-btn').addEventListener('click', () => {
            this.toggleSettings(true);
        });

        document.getElementById('settings-close-btn').addEventListener('click', () => {
            this.toggleSettings(false);
        });

        // Settings toggles
        document.getElementById('pose-detection-toggle').addEventListener('change', (e) => {
            this.state.poseDetectionEnabled = e.target.checked;
            if (e.target.checked && this.state.stream) {
                this.initPoseDetection();
            }
        });

        document.getElementById('grid-toggle').addEventListener('change', (e) => {
            this.state.gridEnabled = e.target.checked;
            this.elements.gridOverlay.classList.toggle('hidden', !e.target.checked);
            if (e.target.checked) {
                this.updateGridPosition();
            }
        });

        document.getElementById('level-toggle').addEventListener('change', (e) => {
            this.state.levelEnabled = e.target.checked;
            this.elements.levelIndicator.classList.toggle('hidden', !e.target.checked);
            if (e.target.checked) {
                this.startDeviceOrientation();
            }
        });

        document.getElementById('sound-toggle').addEventListener('change', (e) => {
            this.state.soundEnabled = e.target.checked;
        });

        // Guide selection
        document.querySelectorAll('.guide-option').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const guide = e.currentTarget.dataset.guide;
                this.setGuide(guide);
            });
        });

        // Timer selection
        document.querySelectorAll('.timer-option').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const timer = parseInt(e.currentTarget.dataset.timer);
                this.setTimer(timer);
            });
        });

        // Preview actions
        document.getElementById('retake-btn').addEventListener('click', () => {
            this.showScreen('camera');
        });

        document.getElementById('save-btn').addEventListener('click', () => {
            this.savePhoto();
        });

        // Guide edit mode
        this.elements.editGuideBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleGuideEditMode();
        });

        document.getElementById('reset-guide-btn').addEventListener('click', () => {
            this.resetGuidePosition();
        });

        document.getElementById('done-guide-btn').addEventListener('click', () => {
            this.toggleGuideEditMode(false);
        });

        // Guide drag events
        this.setupGuideDragEvents();

        // Close panels on outside click
        document.addEventListener('click', (e) => {
            if (this.elements.settingsPanel.classList.contains('visible')) {
                if (!this.elements.settingsPanel.contains(e.target) &&
                    e.target.id !== 'settings-btn') {
                    this.toggleSettings(false);
                }
            }

            if (this.state.ratioPanelOpen) {
                if (!this.elements.ratioPanel.contains(e.target) &&
                    e.target.id !== 'ratio-btn' &&
                    !e.target.closest('#ratio-btn')) {
                    this.toggleRatioPanel(false);
                }
            }
        });

        // Window resize
        window.addEventListener('resize', () => {
            if (this.state.currentScreen === 'camera') {
                this.updateRatioMask();
                this.updateGridPosition();
                this.updateGuidePosition();
            }
        });

        // Orientation change
        window.addEventListener('orientationchange', () => {
            setTimeout(() => this.handleOrientationChange(), 100);
        });

        screen.orientation?.addEventListener('change', () => {
            setTimeout(() => this.handleOrientationChange(), 100);
        });
    }

    handleOrientationChange() {
        const isLandscape = window.innerWidth > window.innerHeight;
        document.body.classList.toggle('landscape', isLandscape);

        if (this.state.currentScreen === 'camera') {
            this.updateRatioMask();
            this.updateGridPosition();
            this.updateGuidePosition();
        }
    }

    setupGuideDragEvents() {
        const guideFrame = this.elements.guideFrame;

        // Touch events
        guideFrame.addEventListener('touchstart', (e) => this.onDragStart(e), { passive: false });
        guideFrame.addEventListener('touchmove', (e) => this.onDragMove(e), { passive: false });
        guideFrame.addEventListener('touchend', (e) => this.onDragEnd(e));

        // Mouse events
        guideFrame.addEventListener('mousedown', (e) => this.onDragStart(e));
        document.addEventListener('mousemove', (e) => this.onDragMove(e));
        document.addEventListener('mouseup', (e) => this.onDragEnd(e));

        // Resize handles
        this.elements.resizeHandles.forEach(handle => {
            handle.addEventListener('touchstart', (e) => this.onResizeStart(e), { passive: false });
            handle.addEventListener('mousedown', (e) => this.onResizeStart(e));
        });
    }

    onDragStart(e) {
        if (!this.state.guideEditMode) return;
        if (e.target.classList.contains('resize-handle') || e.target.classList.contains('edit-guide-btn')) return;

        e.preventDefault();
        this.state.isDragging = true;

        const point = e.touches ? e.touches[0] : e;
        this.state.dragStart = {
            x: point.clientX,
            y: point.clientY,
            posX: this.state.guidePosition.x,
            posY: this.state.guidePosition.y
        };
    }

    onDragMove(e) {
        if (!this.state.isDragging && !this.state.isResizing) return;

        e.preventDefault();
        const point = e.touches ? e.touches[0] : e;
        const container = document.querySelector('.camera-container');
        const rect = container.getBoundingClientRect();

        if (this.state.isDragging) {
            const deltaX = ((point.clientX - this.state.dragStart.x) / rect.width) * 100;
            const deltaY = ((point.clientY - this.state.dragStart.y) / rect.height) * 100;

            this.state.guidePosition.x = Math.max(10, Math.min(90, this.state.dragStart.posX + deltaX));
            this.state.guidePosition.y = Math.max(10, Math.min(90, this.state.dragStart.posY + deltaY));

            this.updateGuidePosition();
        }

        if (this.state.isResizing) {
            const deltaX = point.clientX - this.state.dragStart.x;
            const scaleDelta = deltaX / 100;
            this.state.guideScale = Math.max(0.5, Math.min(2, this.state.dragStart.scale + scaleDelta));
            this.updateGuideSize();
        }
    }

    onDragEnd(e) {
        if (this.state.isDragging || this.state.isResizing) {
            this.saveCurrentGuidePosition();
        }
        this.state.isDragging = false;
        this.state.isResizing = false;
    }

    onResizeStart(e) {
        if (!this.state.guideEditMode) return;

        e.preventDefault();
        e.stopPropagation();
        this.state.isResizing = true;

        const point = e.touches ? e.touches[0] : e;
        this.state.dragStart = {
            x: point.clientX,
            y: point.clientY,
            scale: this.state.guideScale
        };
    }

    showScreen(screenName) {
        Object.keys(this.screens).forEach(key => {
            this.screens[key].classList.remove('active');
        });
        this.screens[screenName].classList.add('active');
        this.state.currentScreen = screenName;

        if (screenName === 'camera') {
            setTimeout(() => {
                this.updateRatioMask();
                this.updateGridPosition();
            }, 100);
        }
    }

    async startCamera() {
        try {
            const constraints = {
                video: {
                    facingMode: this.state.cameraFacing,
                    width: { ideal: 1920 },
                    height: { ideal: 1080 }
                },
                audio: false
            };

            this.state.stream = await navigator.mediaDevices.getUserMedia(constraints);
            this.elements.video.srcObject = this.state.stream;

            this.state.videoTrack = this.state.stream.getVideoTracks()[0];
            await this.checkTorchSupport();

            this.elements.video.onloadedmetadata = () => {
                this.resizeCanvases();
                this.updateRatioMask();
                this.updateGridPosition();
                if (this.state.poseDetectionEnabled) {
                    this.initPoseDetection();
                }
            };
        } catch (error) {
            console.error('Camera access error:', error);
            alert('카메라에 접근할 수 없습니다. 권한을 확인해주세요.');
        }
    }

    async checkTorchSupport() {
        if (!this.state.videoTrack) return;

        try {
            const capabilities = this.state.videoTrack.getCapabilities();
            this.state.flashSupported = capabilities && capabilities.torch;

            if (!this.state.flashSupported) {
                this.elements.flashBtn.style.opacity = '0.3';
            } else {
                this.elements.flashBtn.style.opacity = '1';
            }
        } catch (e) {
            console.warn('Could not check torch support:', e);
            this.state.flashSupported = false;
        }
    }

    stopCamera() {
        if (this.state.flashEnabled) {
            this.setTorch(false);
        }

        if (this.state.stream) {
            this.state.stream.getTracks().forEach(track => track.stop());
            this.state.stream = null;
            this.state.videoTrack = null;
        }
    }

    async switchCamera() {
        if (this.state.flashEnabled) {
            this.state.flashEnabled = false;
            this.updateFlashUI();
        }

        this.state.cameraFacing = this.state.cameraFacing === 'environment' ? 'user' : 'environment';
        this.stopCamera();
        await this.startCamera();
    }

    resizeCanvases() {
        const video = this.elements.video;
        const width = video.videoWidth;
        const height = video.videoHeight;

        this.elements.overlayCanvas.width = width;
        this.elements.overlayCanvas.height = height;
        this.elements.poseCanvas.width = width;
        this.elements.poseCanvas.height = height;
    }

    // Ratio Functions
    setRatio(ratio) {
        this.state.currentRatio = ratio;

        document.querySelectorAll('.ratio-option').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.ratio === ratio);
        });

        this.elements.ratioLabel.textContent = ratio === 'full' ? 'Full' : ratio;

        this.updateRatioMask();
        this.updateGridPosition();
    }

    updateRatioMask() {
        const mask = this.elements.ratioMask;
        const container = document.querySelector('.camera-container');
        if (!container) return;

        const containerRect = container.getBoundingClientRect();
        const containerWidth = containerRect.width;
        const containerHeight = containerRect.height;

        if (this.state.currentRatio === 'full') {
            mask.style.setProperty('--mask-top', '0px');
            mask.style.setProperty('--mask-bottom', '0px');
            mask.style.setProperty('--mask-side', '0px');
            mask.classList.remove('horizontal');
            return;
        }

        const ratioData = this.ratios[this.state.currentRatio];
        const targetRatio = ratioData.width / ratioData.height;
        const containerRatio = containerWidth / containerHeight;

        if (targetRatio < containerRatio) {
            const targetHeight = containerHeight;
            const targetWidth = targetHeight * targetRatio;
            const sideMargin = (containerWidth - targetWidth) / 2;

            mask.classList.add('horizontal');
            mask.style.setProperty('--mask-side', `${sideMargin}px`);
            mask.style.setProperty('--mask-top', '0px');
            mask.style.setProperty('--mask-bottom', '0px');
        } else {
            const targetWidth = containerWidth;
            const targetHeight = targetWidth / targetRatio;
            const verticalMargin = (containerHeight - targetHeight) / 2;

            mask.classList.remove('horizontal');
            mask.style.setProperty('--mask-top', `${verticalMargin}px`);
            mask.style.setProperty('--mask-bottom', `${verticalMargin}px`);
            mask.style.setProperty('--mask-side', '0px');
        }
    }

    updateGridPosition() {
        const grid = this.elements.gridOverlay;
        const container = document.querySelector('.camera-container');
        if (!container || !grid) return;

        const containerRect = container.getBoundingClientRect();
        const containerWidth = containerRect.width;
        const containerHeight = containerRect.height;

        if (this.state.currentRatio === 'full') {
            grid.style.setProperty('--grid-top', '0px');
            grid.style.setProperty('--grid-bottom', '0px');
            grid.style.setProperty('--grid-left', '0px');
            grid.style.setProperty('--grid-right', '0px');
            return;
        }

        const ratioData = this.ratios[this.state.currentRatio];
        const targetRatio = ratioData.width / ratioData.height;
        const containerRatio = containerWidth / containerHeight;

        if (targetRatio < containerRatio) {
            const targetHeight = containerHeight;
            const targetWidth = targetHeight * targetRatio;
            const sideMargin = (containerWidth - targetWidth) / 2;

            grid.style.setProperty('--grid-top', '0px');
            grid.style.setProperty('--grid-bottom', '0px');
            grid.style.setProperty('--grid-left', `${sideMargin}px`);
            grid.style.setProperty('--grid-right', `${sideMargin}px`);
        } else {
            const targetWidth = containerWidth;
            const targetHeight = targetWidth / targetRatio;
            const verticalMargin = (containerHeight - targetHeight) / 2;

            grid.style.setProperty('--grid-top', `${verticalMargin}px`);
            grid.style.setProperty('--grid-bottom', `${verticalMargin}px`);
            grid.style.setProperty('--grid-left', '0px');
            grid.style.setProperty('--grid-right', '0px');
        }
    }

    toggleRatioPanel(show) {
        if (show === undefined) {
            show = !this.state.ratioPanelOpen;
        }

        this.state.ratioPanelOpen = show;
        this.elements.ratioPanel.classList.toggle('hidden', !show);
    }

    // Flash Functions
    async toggleFlash() {
        if (!this.state.flashSupported) {
            this.showAlignmentFeedback('이 기기에서는 플래시를 지원하지 않습니다', false);
            setTimeout(() => this.hideAlignmentFeedback(), 2000);
            return;
        }

        this.state.flashEnabled = !this.state.flashEnabled;
        await this.setTorch(this.state.flashEnabled);
        this.updateFlashUI();
    }

    async setTorch(enabled) {
        if (!this.state.videoTrack || !this.state.flashSupported) return;

        try {
            await this.state.videoTrack.applyConstraints({
                advanced: [{ torch: enabled }]
            });
        } catch (e) {
            console.error('Failed to set torch:', e);
            this.state.flashEnabled = false;
            this.updateFlashUI();
        }
    }

    updateFlashUI() {
        const btn = this.elements.flashBtn;
        btn.dataset.flash = this.state.flashEnabled ? 'on' : 'off';

        this.elements.flashIconOff.classList.toggle('hidden', this.state.flashEnabled);
        this.elements.flashIconOn.classList.toggle('hidden', !this.state.flashEnabled);
    }

    // Guide Edit Mode
    toggleGuideEditMode(enable) {
        if (enable === undefined) {
            enable = !this.state.guideEditMode;
        }

        this.state.guideEditMode = enable;
        this.elements.guideFrame.classList.toggle('editing', enable);
        this.elements.guideEditToolbar.classList.toggle('hidden', !enable);

        // Show/hide resize handles
        this.elements.resizeHandles.forEach(handle => {
            handle.classList.toggle('hidden', !enable);
        });

        // Hide other controls when editing
        document.querySelector('.bottom-controls').style.opacity = enable ? '0.3' : '1';
        document.querySelector('.bottom-controls').style.pointerEvents = enable ? 'none' : 'auto';
    }

    resetGuidePosition() {
        this.state.guidePosition = { x: 50, y: 50 };
        this.state.guideScale = 1;
        this.updateGuidePosition();
        this.updateGuideSize();
        this.saveCurrentGuidePosition();
    }

    updateGuidePosition() {
        const frame = this.elements.guideFrame;
        frame.style.left = `${this.state.guidePosition.x}%`;
        frame.style.top = `${this.state.guidePosition.y}%`;
    }

    updateGuideSize() {
        if (this.state.currentGuide === 'none') return;

        const defaultSize = this.defaultGuideSizes[this.state.currentGuide];
        const silhouette = this.elements.guideSilhouette;

        silhouette.style.width = `${defaultSize.width * this.state.guideScale}px`;
        silhouette.style.height = `${defaultSize.height * this.state.guideScale}px`;
    }

    saveCurrentGuidePosition() {
        if (this.state.currentGuide === 'none') return;

        this.state.savedGuidePositions[this.state.currentGuide] = {
            x: this.state.guidePosition.x,
            y: this.state.guidePosition.y,
            scale: this.state.guideScale
        };

        this.saveGuidePositions();
    }

    loadGuidePosition(guideType) {
        // Always start from center, ignore saved positions
        this.state.guidePosition = { x: 50, y: 50 };
        this.state.guideScale = 1;
        this.updateGuidePosition();
        this.updateGuideSize();
    }

    saveGuidePositions() {
        try {
            localStorage.setItem('godaero_guide_positions', JSON.stringify(this.state.savedGuidePositions));
        } catch (e) {
            console.warn('Failed to save guide positions:', e);
        }
    }

    loadGuidePositions() {
        try {
            const saved = localStorage.getItem('godaero_guide_positions');
            if (saved) {
                this.state.savedGuidePositions = JSON.parse(saved);
            }
        } catch (e) {
            console.warn('Failed to load guide positions:', e);
        }
    }

    // Pose Detection
    initPoseDetection() {
        if (typeof Pose === 'undefined') {
            console.warn('MediaPipe Pose not loaded');
            return;
        }

        this.state.pose = new Pose({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
            }
        });

        this.state.pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        this.state.pose.onResults((results) => {
            this.onPoseResults(results);
        });

        this.startPoseDetection();
    }

    async startPoseDetection() {
        if (!this.state.pose || !this.state.stream) return;

        const detectFrame = async () => {
            if (this.state.currentScreen !== 'camera' || !this.state.poseDetectionEnabled) return;

            try {
                await this.state.pose.send({ image: this.elements.video });
            } catch (e) {
                console.warn('Pose detection error:', e);
            }

            requestAnimationFrame(detectFrame);
        };

        detectFrame();
    }

    onPoseResults(results) {
        this.poseCtx.clearRect(0, 0, this.elements.poseCanvas.width, this.elements.poseCanvas.height);

        if (results.poseLandmarks && this.state.currentGuide !== 'none') {
            this.drawPoseLandmarks(results.poseLandmarks);
            this.checkAlignment(results.poseLandmarks);
        }
    }

    drawPoseLandmarks(landmarks) {
        const canvas = this.elements.poseCanvas;
        const ctx = this.poseCtx;

        const connections = [
            [11, 12], [11, 13], [13, 15], [12, 14], [14, 16],
            [11, 23], [12, 24], [23, 24], [23, 25], [25, 27], [24, 26], [26, 28]
        ];

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.lineWidth = 2;

        connections.forEach(([i, j]) => {
            const p1 = landmarks[i];
            const p2 = landmarks[j];

            if (p1.visibility > 0.5 && p2.visibility > 0.5) {
                ctx.beginPath();
                ctx.moveTo(p1.x * canvas.width, p1.y * canvas.height);
                ctx.lineTo(p2.x * canvas.width, p2.y * canvas.height);
                ctx.stroke();
            }
        });

        const keyPoints = [11, 12, 13, 14, 15, 16, 23, 24, 25, 26, 27, 28];
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';

        keyPoints.forEach(i => {
            const point = landmarks[i];
            if (point.visibility > 0.5) {
                ctx.beginPath();
                ctx.arc(point.x * canvas.width, point.y * canvas.height, 4, 0, 2 * Math.PI);
                ctx.fill();
            }
        });
    }

    checkAlignment(landmarks) {
        if (this.state.currentGuide === 'none' || this.state.guideEditMode) {
            this.hideAlignmentFeedback();
            return;
        }

        // Get key body points for bounding box
        const nose = landmarks[0];
        const leftShoulder = landmarks[11];
        const rightShoulder = landmarks[12];
        const leftHip = landmarks[23];
        const rightHip = landmarks[24];
        const leftAnkle = landmarks[27];
        const rightAnkle = landmarks[28];

        // Check if person is detected
        if (leftShoulder.visibility < 0.5 || rightShoulder.visibility < 0.5) {
            this.showAlignmentFeedback('사람을 프레임 안에 위치시켜주세요', 'none');
            return;
        }

        // Calculate person's bounding box (normalized 0-1)
        const visiblePoints = [nose, leftShoulder, rightShoulder, leftHip, rightHip, leftAnkle, rightAnkle]
            .filter(p => p && p.visibility > 0.3);

        if (visiblePoints.length < 3) {
            this.showAlignmentFeedback('사람을 프레임 안에 위치시켜주세요', 'none');
            return;
        }

        const personLeft = Math.min(...visiblePoints.map(p => p.x));
        const personRight = Math.max(...visiblePoints.map(p => p.x));
        const personTop = Math.min(...visiblePoints.map(p => p.y));
        const personBottom = Math.max(...visiblePoints.map(p => p.y));

        const personCenterX = (personLeft + personRight) / 2;
        const personCenterY = (personTop + personBottom) / 2;
        const personWidth = personRight - personLeft;
        const personHeight = personBottom - personTop;

        // Get guide position and size (normalized)
        const guideX = this.state.guidePosition.x / 100;
        const guideY = this.state.guidePosition.y / 100;

        // Estimate guide size based on container
        const container = document.querySelector('.camera-container');
        if (!container) return;

        const containerRect = container.getBoundingClientRect();
        const defaultSize = this.defaultGuideSizes[this.state.currentGuide];
        const guideWidth = (defaultSize.width * this.state.guideScale) / containerRect.width;
        const guideHeight = (defaultSize.height * this.state.guideScale) / containerRect.height;

        const guideLeft = guideX - guideWidth / 2;
        const guideRight = guideX + guideWidth / 2;
        const guideTop = guideY - guideHeight / 2;
        const guideBottom = guideY + guideHeight / 2;

        // Check overlap between person and guide
        const overlapLeft = Math.max(personLeft, guideLeft);
        const overlapRight = Math.min(personRight, guideRight);
        const overlapTop = Math.max(personTop, guideTop);
        const overlapBottom = Math.min(personBottom, guideBottom);

        const overlapWidth = Math.max(0, overlapRight - overlapLeft);
        const overlapHeight = Math.max(0, overlapBottom - overlapTop);
        const overlapArea = overlapWidth * overlapHeight;
        const personArea = personWidth * personHeight;

        const overlapRatio = personArea > 0 ? overlapArea / personArea : 0;

        // Check alignment
        const horizontalDiff = Math.abs(personCenterX - guideX);
        const verticalDiff = Math.abs(personCenterY - guideY);
        const shoulderDiff = Math.abs(leftShoulder.y - rightShoulder.y);
        const isLevel = shoulderDiff < 0.03;

        // Determine state based on overlap and alignment
        if (overlapRatio > 0.6 && horizontalDiff < 0.08 && verticalDiff < 0.1 && isLevel) {
            // Perfect alignment
            this.showAlignmentFeedback('완벽해요! 지금 찍으세요!', 'perfect');
        } else if (overlapRatio > 0.3) {
            // Partial overlap - person is in guide area
            if (!isLevel) {
                this.showAlignmentFeedback('카메라를 수평으로 맞춰주세요', 'partial');
            } else if (horizontalDiff > 0.08) {
                const direction = personCenterX < guideX ? '오른쪽' : '왼쪽';
                this.showAlignmentFeedback(`${direction}으로 조금 이동해주세요`, 'partial');
            } else if (verticalDiff > 0.1) {
                const direction = personCenterY < guideY ? '아래' : '위';
                this.showAlignmentFeedback(`${direction}로 이동해주세요`, 'partial');
            } else {
                this.showAlignmentFeedback('조금만 더 맞춰주세요', 'partial');
            }
        } else if (overlapRatio > 0) {
            // Person detected but not well aligned
            this.showAlignmentFeedback('가이드 안으로 들어와주세요', 'detected');
        } else {
            // No overlap
            this.showAlignmentFeedback('가이드 안으로 이동해주세요', 'detected');
        }
    }

    showAlignmentFeedback(message, state) {
        this.elements.feedbackText.textContent = message;
        this.elements.alignmentFeedback.classList.add('visible');
        this.elements.alignmentFeedback.classList.toggle('aligned', state === 'perfect');

        // Remove all state classes first
        this.elements.guideFrame.classList.remove('perfect', 'partial', 'detected');

        // Add current state class
        if (state !== 'none') {
            this.elements.guideFrame.classList.add(state);
        }

        // Show/hide perfect alignment indicators
        this.elements.captureBtn.classList.toggle('ready', state === 'perfect');
        this.elements.shootIndicator.classList.toggle('visible', state === 'perfect');
    }

    hideAlignmentFeedback() {
        this.elements.alignmentFeedback.classList.remove('visible', 'aligned');
        this.elements.guideFrame.classList.remove('perfect', 'partial', 'detected');
        this.elements.captureBtn.classList.remove('ready');
        this.elements.shootIndicator.classList.remove('visible');
    }

    setGuide(guide) {
        // Exit edit mode if active
        if (this.state.guideEditMode) {
            this.toggleGuideEditMode(false);
        }

        this.state.currentGuide = guide;

        document.querySelectorAll('.guide-option').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.guide === guide);
        });

        if (guide === 'none') {
            this.elements.guideFrame.classList.add('hidden');
            this.hideAlignmentFeedback();
        } else {
            this.elements.guideFrame.classList.remove('hidden');
            this.elements.guideFrame.dataset.guide = guide;
            this.loadGuidePosition(guide);
            this.updateGuideFrame(guide);
        }
    }

    updateGuideFrame(guide) {
        const silhouette = this.elements.guideSilhouette;
        const defaultSize = this.defaultGuideSizes[guide];

        silhouette.style.width = `${defaultSize.width * this.state.guideScale}px`;
        silhouette.style.height = `${defaultSize.height * this.state.guideScale}px`;

        // Remove border-radius as the shape is now defined in CSS with gradients
        silhouette.style.borderRadius = '';
    }

    setTimer(duration) {
        this.state.timerDuration = duration;

        document.querySelectorAll('.timer-option').forEach(btn => {
            btn.classList.toggle('active', parseInt(btn.dataset.timer) === duration);
        });
    }

    toggleSettings(show) {
        if (show) {
            this.elements.settingsPanel.classList.remove('hidden');
            setTimeout(() => {
                this.elements.settingsPanel.classList.add('visible');
            }, 10);
        } else {
            this.elements.settingsPanel.classList.remove('visible');
            setTimeout(() => {
                this.elements.settingsPanel.classList.add('hidden');
            }, 300);
        }
    }

    async capturePhoto() {
        if (this.state.isCapturing) return;

        if (this.state.timerDuration > 0) {
            await this.startCountdown();
        }

        this.state.isCapturing = true;

        this.createFlashEffect();

        if (this.state.soundEnabled) {
            this.playShutterSound();
        }

        // Capture ONLY the video - no grid or overlays
        const video = this.elements.video;
        const videoWidth = video.videoWidth;
        const videoHeight = video.videoHeight;

        let cropX = 0, cropY = 0, cropWidth = videoWidth, cropHeight = videoHeight;

        if (this.state.currentRatio !== 'full') {
            const ratioData = this.ratios[this.state.currentRatio];
            const targetRatio = ratioData.width / ratioData.height;
            const videoRatio = videoWidth / videoHeight;

            if (targetRatio < videoRatio) {
                cropHeight = videoHeight;
                cropWidth = cropHeight * targetRatio;
                cropX = (videoWidth - cropWidth) / 2;
            } else {
                cropWidth = videoWidth;
                cropHeight = cropWidth / targetRatio;
                cropY = (videoHeight - cropHeight) / 2;
            }
        }

        const canvas = document.createElement('canvas');
        canvas.width = cropWidth;
        canvas.height = cropHeight;

        const ctx = canvas.getContext('2d');

        if (this.state.cameraFacing === 'user') {
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
        }

        // Draw ONLY the video frame - nothing else
        ctx.drawImage(video, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

        const imageData = canvas.toDataURL('image/jpeg', 0.95);

        this.elements.previewImage.src = imageData;
        this.showScreen('preview');

        this.state.isCapturing = false;
    }

    async startCountdown() {
        return new Promise((resolve) => {
            let count = this.state.timerDuration;
            this.elements.timerCountdown.classList.remove('hidden');
            this.elements.countdownNumber.textContent = count;

            const interval = setInterval(() => {
                count--;
                if (count > 0) {
                    this.elements.countdownNumber.textContent = count;
                } else {
                    clearInterval(interval);
                    this.elements.timerCountdown.classList.add('hidden');
                    resolve();
                }
            }, 1000);
        });
    }

    createFlashEffect() {
        const flash = document.createElement('div');
        flash.className = 'flash-effect';
        document.body.appendChild(flash);

        setTimeout(() => {
            flash.remove();
        }, 150);
    }

    playShutterSound() {
        try {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.frequency.value = 800;
            oscillator.type = 'sine';
            gainNode.gain.value = 0.1;

            oscillator.start();
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            oscillator.stop(audioCtx.currentTime + 0.1);
        } catch (e) {
            console.warn('Could not play shutter sound:', e);
        }
    }

    savePhoto() {
        const imageData = this.elements.previewImage.src;

        const photo = {
            id: Date.now(),
            data: imageData,
            timestamp: new Date().toISOString()
        };

        this.state.photos.unshift(photo);
        this.savePhotosToStorage();
        this.updateGalleryPreview();

        const link = document.createElement('a');
        link.download = `godaero_${photo.id}.jpg`;
        link.href = imageData;
        link.click();

        this.showScreen('camera');
    }

    savePhotosToStorage() {
        try {
            const photosToSave = this.state.photos.slice(0, 20);
            localStorage.setItem('godaero_photos', JSON.stringify(photosToSave));
        } catch (e) {
            console.warn('Failed to save photos to storage:', e);
        }
    }

    loadPhotosFromStorage() {
        try {
            const saved = localStorage.getItem('godaero_photos');
            if (saved) {
                this.state.photos = JSON.parse(saved);
            }
        } catch (e) {
            console.warn('Failed to load photos from storage:', e);
        }
    }

    updateGalleryPreview() {
        if (this.state.photos.length > 0) {
            this.elements.galleryPreview.style.backgroundImage = `url(${this.state.photos[0].data})`;
        }
    }

    renderGallery() {
        const grid = this.elements.galleryGrid;
        grid.innerHTML = '';

        if (this.state.photos.length === 0) {
            this.elements.galleryEmpty.classList.remove('hidden');
            return;
        }

        this.elements.galleryEmpty.classList.add('hidden');

        this.state.photos.forEach(photo => {
            const item = document.createElement('div');
            item.className = 'gallery-item';
            item.style.backgroundImage = `url(${photo.data})`;
            item.addEventListener('click', () => {
                this.viewPhoto(photo);
            });
            grid.appendChild(item);
        });
    }

    viewPhoto(photo) {
        this.elements.previewImage.src = photo.data;
        this.showScreen('preview');

        const saveBtn = document.getElementById('save-btn');
        saveBtn.textContent = '다운로드';
        saveBtn.onclick = () => {
            const link = document.createElement('a');
            link.download = `godaero_${photo.id}.jpg`;
            link.href = photo.data;
            link.click();
        };

        document.getElementById('retake-btn').onclick = () => {
            saveBtn.textContent = '저장';
            saveBtn.onclick = () => this.savePhoto();
            this.showScreen('gallery');
        };
    }

    startDeviceOrientation() {
        if (typeof DeviceOrientationEvent !== 'undefined') {
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', (e) => this.handleOrientation(e));
                        }
                    })
                    .catch(console.error);
            } else {
                window.addEventListener('deviceorientation', (e) => this.handleOrientation(e));
            }
        }
    }

    handleOrientation(event) {
        if (!this.state.levelEnabled) return;

        const gamma = event.gamma || 0;
        const beta = event.beta || 0;

        const normalizedGamma = Math.max(-45, Math.min(45, gamma));
        const bubblePosition = 50 + (normalizedGamma / 45) * 40;

        this.elements.levelBubble.style.left = `${bubblePosition}%`;

        const isLevel = Math.abs(gamma) < 3 && Math.abs(beta - 90) < 10;
        this.elements.levelIndicator.classList.toggle('level', isLevel);
    }
}

// Initialize app when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.app = new MomentieApp();
});


=== styles.css ===
/* Reset & Base */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
}

html, body {
    height: 100%;
    overflow: hidden;
}

body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: #000;
    color: #fff;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

#app {
    height: 100%;
    width: 100%;
    position: relative;
    max-width: 500px;
    margin: 0 auto;
}

/* Screen Base */
.screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: none;
    flex-direction: column;
    background: #000;
}

.screen.active {
    display: flex;
}

/* Splash Screen */
#splash-screen {
    justify-content: center;
    align-items: center;
    background: linear-gradient(180deg, #1a1a1a 0%, #000 100%);
}

.splash-content {
    text-align: center;
    padding: 40px;
}

.logo {
    font-size: 42px;
    font-weight: 300;
    letter-spacing: -1px;
    margin-bottom: 12px;
    background: linear-gradient(135deg, #fff 0%, #999 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.tagline {
    font-size: 15px;
    color: #666;
    font-weight: 300;
    margin-bottom: 48px;
    letter-spacing: 0.5px;
}

/* Buttons */
.btn-primary {
    background: #fff;
    color: #000;
    border: none;
    padding: 16px 48px;
    border-radius: 30px;
    font-size: 15px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    letter-spacing: 0.3px;
}

.btn-primary:active {
    transform: scale(0.96);
    background: #e5e5e5;
}

.text-btn {
    background: transparent;
    color: #fff;
    border: 1px solid rgba(255,255,255,0.2);
    padding: 14px 32px;
    border-radius: 30px;
    font-size: 14px;
    font-weight: 400;
    cursor: pointer;
    transition: all 0.2s ease;
}

.text-btn:active {
    background: rgba(255,255,255,0.1);
}

.icon-btn {
    background: transparent;
    border: none;
    color: #fff;
    width: 44px;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    border-radius: 50%;
    transition: background 0.2s ease;
}

.icon-btn:active {
    background: rgba(255,255,255,0.1);
}

/* Camera Screen */
#camera-screen {
    background: #000;
}

.camera-container {
    flex: 1;
    position: relative;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
}

#camera-feed {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

#overlay-canvas,
#pose-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

/* Guide Frame */
.guide-frame {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    transition: opacity 0.3s ease;
}

.guide-frame.hidden {
    opacity: 0;
}

/* Base silhouette - Portrait (1 person) */
.guide-silhouette {
    width: 140px;
    height: 280px;
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
}

/* Head */
.guide-silhouette::before {
    content: '';
    width: 65px;
    height: 65px;
    border: 3px solid rgba(255,255,255,0.6);
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.1), transparent 70%);
    box-shadow:
        0 0 0 1px rgba(255,255,255,0.2),
        inset 0 2px 4px rgba(0,0,0,0.1);
    margin-bottom: 5px;
}

/* Body - Upper torso with shoulders */
.guide-silhouette::after {
    content: '';
    width: 110px;
    height: 190px;
    border: 3px solid rgba(255,255,255,0.6);
    border-radius: 55px 55px 40px 40px;
    background:
        radial-gradient(ellipse at 50% 20%, rgba(255,255,255,0.08), transparent 60%),
        rgba(255,255,255,0.03);
    box-shadow:
        0 0 0 1px rgba(255,255,255,0.2),
        inset 0 10px 20px rgba(0,0,0,0.05);
}

/* Couple (2 people side by side) */
.guide-frame[data-guide="couple"] .guide-silhouette {
    width: 240px;
    height: 280px;
}

.guide-frame[data-guide="couple"] .guide-silhouette::before {
    display: none;
}

.guide-frame[data-guide="couple"] .guide-silhouette::after {
    display: none;
}

.guide-frame[data-guide="couple"] .guide-silhouette {
    background-image:
        /* Person 1 - Head */
        radial-gradient(circle 32px at 28% 50px, rgba(255,255,255,0.03) 100%, transparent 100%),
        radial-gradient(circle 35px at 28% 50px, rgba(0,0,0,0) 90%, rgba(255,255,255,0.6) 90%, rgba(255,255,255,0.6) 100%, transparent 100%),
        /* Person 1 - Body */
        radial-gradient(ellipse 52px 95px at 28% 165px, rgba(255,255,255,0.03) 100%, transparent 100%),
        radial-gradient(ellipse 55px 98px at 28% 165px, rgba(0,0,0,0) 95%, rgba(255,255,255,0.6) 95%, rgba(255,255,255,0.6) 100%, transparent 100%),
        /* Person 2 - Head */
        radial-gradient(circle 32px at 72% 50px, rgba(255,255,255,0.03) 100%, transparent 100%),
        radial-gradient(circle 35px at 72% 50px, rgba(0,0,0,0) 90%, rgba(255,255,255,0.6) 90%, rgba(255,255,255,0.6) 100%, transparent 100%),
        /* Person 2 - Body */
        radial-gradient(ellipse 52px 95px at 72% 165px, rgba(255,255,255,0.03) 100%, transparent 100%),
        radial-gradient(ellipse 55px 98px at 72% 165px, rgba(0,0,0,0) 95%, rgba(255,255,255,0.6) 95%, rgba(255,255,255,0.6) 100%, transparent 100%);
    background-repeat: no-repeat;
}

/* Group (3 people) */
.guide-frame[data-guide="group"] .guide-silhouette {
    width: 310px;
    height: 240px;
}

.guide-frame[data-guide="group"] .guide-silhouette::before {
    display: none;
}

.guide-frame[data-guide="group"] .guide-silhouette::after {
    display: none;
}

.guide-frame[data-guide="group"] .guide-silhouette {
    background-image:
        /* Person 1 - Head */
        radial-gradient(circle 28px at 18% 45px, rgba(255,255,255,0.03) 100%, transparent 100%),
        radial-gradient(circle 31px at 18% 45px, rgba(0,0,0,0) 88%, rgba(255,255,255,0.6) 88%, rgba(255,255,255,0.6) 100%, transparent 100%),
        /* Person 1 - Body */
        radial-gradient(ellipse 45px 82px at 18% 145px, rgba(255,255,255,0.03) 100%, transparent 100%),
        radial-gradient(ellipse 48px 85px at 18% 145px, rgba(0,0,0,0) 94%, rgba(255,255,255,0.6) 94%, rgba(255,255,255,0.6) 100%, transparent 100%),
        /* Person 2 - Head */
        radial-gradient(circle 28px at 50% 45px, rgba(255,255,255,0.03) 100%, transparent 100%),
        radial-gradient(circle 31px at 50% 45px, rgba(0,0,0,0) 88%, rgba(255,255,255,0.6) 88%, rgba(255,255,255,0.6) 100%, transparent 100%),
        /* Person 2 - Body */
        radial-gradient(ellipse 45px 82px at 50% 145px, rgba(255,255,255,0.03) 100%, transparent 100%),
        radial-gradient(ellipse 48px 85px at 50% 145px, rgba(0,0,0,0) 94%, rgba(255,255,255,0.6) 94%, rgba(255,255,255,0.6) 100%, transparent 100%),
        /* Person 3 - Head */
        radial-gradient(circle 28px at 82% 45px, rgba(255,255,255,0.03) 100%, transparent 100%),
        radial-gradient(circle 31px at 82% 45px, rgba(0,0,0,0) 88%, rgba(255,255,255,0.6) 88%, rgba(255,255,255,0.6) 100%, transparent 100%),
        /* Person 3 - Body */
        radial-gradient(ellipse 45px 82px at 82% 145px, rgba(255,255,255,0.03) 100%, transparent 100%),
        radial-gradient(ellipse 48px 85px at 82% 145px, rgba(0,0,0,0) 94%, rgba(255,255,255,0.6) 94%, rgba(255,255,255,0.6) 100%, transparent 100%);
    background-repeat: no-repeat;
}

/* Alignment Feedback */
.alignment-feedback {
    position: absolute;
    bottom: 20%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.6);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 10px 20px;
    border-radius: 20px;
    opacity: 0;
    transition: all 0.3s ease;
}

.alignment-feedback.visible {
    opacity: 1;
}

.alignment-feedback.aligned {
    background: rgba(52, 199, 89, 0.8);
}

.feedback-text {
    font-size: 13px;
    font-weight: 500;
    color: #fff;
}

/* Top Bar */
.top-bar {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 8px;
    padding-top: calc(env(safe-area-inset-top, 12px) + 12px);
    background: linear-gradient(180deg, rgba(0,0,0,0.4) 0%, transparent 100%);
    z-index: 10;
}

.top-center {
    display: flex;
    gap: 8px;
}

/* Bottom Controls */
.bottom-controls {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 16px;
    padding-bottom: calc(env(safe-area-inset-bottom, 16px) + 16px);
    background: linear-gradient(0deg, rgba(0,0,0,0.6) 0%, transparent 100%);
    display: flex;
    flex-direction: column;
    gap: 20px;
}

/* Guide Selector */
.guide-selector {
    display: flex;
    justify-content: center;
    gap: 8px;
}

.guide-option {
    background: rgba(255,255,255,0.1);
    border: none;
    padding: 8px 14px;
    border-radius: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.guide-option.active {
    background: rgba(255,255,255,0.25);
}

.guide-option:active {
    transform: scale(0.95);
}

.guide-icon {
    font-size: 18px;
}

.guide-label {
    font-size: 10px;
    color: rgba(255,255,255,0.8);
    font-weight: 400;
}

/* Capture Area */
.capture-area {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 40px;
}

.capture-btn {
    width: 72px;
    height: 72px;
    border-radius: 50%;
    background: transparent;
    border: 4px solid #fff;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s ease;
}

.capture-btn:active {
    transform: scale(0.92);
}

.capture-btn-inner {
    width: 58px;
    height: 58px;
    border-radius: 50%;
    background: #fff;
    transition: all 0.15s ease;
}

.capture-btn:active .capture-btn-inner {
    background: #ccc;
}

.side-btn {
    width: 44px;
    height: 44px;
    border-radius: 12px;
    background: rgba(255,255,255,0.1);
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fff;
    overflow: hidden;
    transition: all 0.2s ease;
}

.side-btn:active {
    transform: scale(0.92);
    background: rgba(255,255,255,0.2);
}

.gallery-preview {
    width: 100%;
    height: 100%;
    background: #333;
    background-size: cover;
    background-position: center;
}

/* Timer Selector */
.timer-selector {
    display: flex;
    justify-content: center;
    gap: 4px;
}

.timer-option {
    background: transparent;
    border: none;
    color: rgba(255,255,255,0.5);
    padding: 8px 16px;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    border-radius: 16px;
    transition: all 0.2s ease;
}

.timer-option.active {
    background: rgba(255,255,255,0.15);
    color: #fff;
}

/* Timer Countdown */
.timer-countdown {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 100;
}

.timer-countdown.hidden {
    display: none;
}

.countdown-number {
    font-size: 120px;
    font-weight: 200;
    color: #fff;
    text-shadow: 0 4px 20px rgba(0,0,0,0.5);
    animation: countdownPulse 1s ease-in-out infinite;
}

@keyframes countdownPulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.1); opacity: 0.8; }
}

/* Preview Screen */
#preview-screen {
    background: #000;
}

.preview-container {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 60px 0;
}

#preview-image {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
}

.preview-controls {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 20px;
    padding-bottom: calc(env(safe-area-inset-bottom, 20px) + 20px);
    display: flex;
    justify-content: center;
    gap: 16px;
    background: linear-gradient(0deg, rgba(0,0,0,0.8) 0%, transparent 100%);
}

/* Gallery Screen */
#gallery-screen {
    background: #000;
}

.gallery-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 8px;
    padding-top: calc(env(safe-area-inset-top, 12px) + 12px);
    border-bottom: 1px solid rgba(255,255,255,0.1);
}

.gallery-header h2 {
    font-size: 17px;
    font-weight: 600;
}

.gallery-grid {
    flex: 1;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 2px;
    padding: 2px;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
}

.gallery-item {
    aspect-ratio: 1;
    background-size: cover;
    background-position: center;
    cursor: pointer;
    transition: opacity 0.2s ease;
}

.gallery-item:active {
    opacity: 0.7;
}

.gallery-empty {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #666;
    font-size: 14px;
}

.gallery-empty.hidden {
    display: none;
}

/* Settings Panel */
.settings-panel {
    position: absolute;
    top: 0;
    right: 0;
    width: 280px;
    max-width: 85%;
    height: 100%;
    background: rgba(28, 28, 30, 0.95);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    z-index: 200;
    transform: translateX(100%);
    transition: transform 0.3s ease;
}

.settings-panel.visible {
    transform: translateX(0);
}

.settings-panel.hidden {
    transform: translateX(100%);
}

.settings-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px;
    padding-top: calc(env(safe-area-inset-top, 16px) + 16px);
    border-bottom: 1px solid rgba(255,255,255,0.1);
}

.settings-header h3 {
    font-size: 17px;
    font-weight: 600;
}

.settings-content {
    padding: 8px 0;
}

.setting-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 14px 16px;
}

.setting-label {
    font-size: 15px;
    color: #fff;
}

/* Toggle Switch */
.toggle {
    position: relative;
    width: 51px;
    height: 31px;
    cursor: pointer;
}

.toggle input {
    opacity: 0;
    width: 0;
    height: 0;
}

.toggle-slider {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(120, 120, 128, 0.32);
    border-radius: 31px;
    transition: all 0.3s ease;
}

.toggle-slider::before {
    content: '';
    position: absolute;
    width: 27px;
    height: 27px;
    left: 2px;
    bottom: 2px;
    background: #fff;
    border-radius: 50%;
    transition: all 0.3s ease;
    box-shadow: 0 3px 8px rgba(0,0,0,0.15);
}

.toggle input:checked + .toggle-slider {
    background: #34c759;
}

.toggle input:checked + .toggle-slider::before {
    transform: translateX(20px);
}

/* Grid Overlay */
.grid-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    z-index: 5;
}

.grid-overlay.hidden {
    display: none;
}

.grid-line {
    position: absolute;
    background: rgba(255,255,255,0.3);
}

.grid-line.horizontal {
    left: 0;
    right: 0;
    height: 1px;
}

.grid-line.vertical {
    top: 0;
    bottom: 0;
    width: 1px;
}

/* Level Indicator */
.level-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 200px;
    height: 40px;
    pointer-events: none;
    z-index: 6;
}

.level-indicator.hidden {
    display: none;
}

.level-line {
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    height: 2px;
    background: rgba(255,255,255,0.3);
    transform: translateY(-50%);
}

.level-bubble {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 12px;
    height: 12px;
    background: #fff;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    transition: left 0.1s ease;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

.level-indicator.level {
    background: rgba(52, 199, 89, 0.3);
    border-radius: 20px;
}

/* Flash Effect */
.flash-effect {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: #fff;
    z-index: 1000;
    pointer-events: none;
    animation: flash 0.15s ease-out forwards;
}

@keyframes flash {
    0% { opacity: 1; }
    100% { opacity: 0; }
}

/* Settings Overlay */
.settings-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.5);
    z-index: 199;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}

.settings-overlay.visible {
    opacity: 1;
    pointer-events: auto;
}

/* Responsive Adjustments */
@media (min-width: 500px) {
    #app {
        border-left: 1px solid #222;
        border-right: 1px solid #222;
    }
}

/* Landscape Warning */
@media (orientation: landscape) and (max-height: 500px) {
    .bottom-controls {
        flex-direction: row;
        justify-content: space-around;
        padding: 12px;
    }

    .guide-selector,
    .timer-selector {
        flex-direction: column;
    }
}

/* Safe area for notch devices */
@supports (padding: max(0px)) {
    .top-bar {
        padding-top: max(12px, env(safe-area-inset-top));
    }

    .bottom-controls {
        padding-bottom: max(16px, env(safe-area-inset-bottom));
    }
}

/* Loading State */
.loading {
    position: relative;
}

.loading::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 24px;
    height: 24px;
    margin: -12px 0 0 -12px;
    border: 2px solid rgba(255,255,255,0.3);
    border-top-color: #fff;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* Ratio Panel */
.ratio-panel {
    position: absolute;
    top: calc(env(safe-area-inset-top, 12px) + 60px);
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 4px;
    background: rgba(0,0,0,0.7);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 6px;
    border-radius: 20px;
    z-index: 15;
    transition: opacity 0.2s ease, transform 0.2s ease;
}

.ratio-panel.hidden {
    opacity: 0;
    transform: translateX(-50%) translateY(-10px);
    pointer-events: none;
}

.ratio-option {
    background: transparent;
    border: none;
    color: rgba(255,255,255,0.6);
    padding: 8px 14px;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    border-radius: 14px;
    transition: all 0.2s ease;
}

.ratio-option.active {
    background: rgba(255,255,255,0.2);
    color: #fff;
}

.ratio-option:active {
    transform: scale(0.95);
}

/* Ratio Label in Top Bar */
.ratio-label {
    font-size: 13px;
    font-weight: 500;
    color: #fff;
}

/* Ratio Mask */
.ratio-mask {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    z-index: 4;
}

.ratio-mask::before,
.ratio-mask::after {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    background: rgba(0,0,0,0.7);
    transition: height 0.3s ease;
}

.ratio-mask::before {
    top: 0;
    height: var(--mask-top, 0);
}

.ratio-mask::after {
    bottom: 0;
    height: var(--mask-bottom, 0);
}

.ratio-mask.horizontal::before,
.ratio-mask.horizontal::after {
    top: 0;
    bottom: 0;
    height: auto;
    width: var(--mask-side, 0);
}

.ratio-mask.horizontal::before {
    left: 0;
    right: auto;
}

.ratio-mask.horizontal::after {
    right: 0;
    left: auto;
}

/* Flash Icon States */
.flash-icon-off,
.flash-icon-on {
    position: absolute;
}

.flash-icon-on.hidden,
.flash-icon-off.hidden {
    display: none;
}

#flash-btn[data-flash="on"] {
    color: #ffd60a;
}

#flash-btn {
    position: relative;
}

/* Guide Edit Mode */
.guide-frame {
    cursor: default;
    touch-action: none;
}

.guide-frame.editing {
    cursor: move;
    pointer-events: auto;
}

.guide-frame.editing .guide-silhouette {
    border-color: rgba(52, 199, 89, 0.8);
    border-style: solid;
}

.edit-guide-btn {
    position: absolute;
    top: -40px;
    right: -10px;
    width: 32px;
    height: 32px;
    background: rgba(255,255,255,0.9);
    border: none;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: #000;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    transition: all 0.2s ease;
    pointer-events: auto;
}

.edit-guide-btn:active {
    transform: scale(0.9);
}

.guide-frame.editing .edit-guide-btn {
    background: #34c759;
    color: #fff;
}

/* Resize Handles */
.resize-handle {
    position: absolute;
    width: 20px;
    height: 20px;
    background: #fff;
    border: 2px solid #34c759;
    border-radius: 50%;
    z-index: 10;
    pointer-events: auto;
}

.resize-handle.hidden {
    display: none;
}

.resize-handle-tl {
    top: -10px;
    left: -10px;
    cursor: nwse-resize;
}

.resize-handle-tr {
    top: -10px;
    right: -10px;
    cursor: nesw-resize;
}

.resize-handle-bl {
    bottom: -10px;
    left: -10px;
    cursor: nesw-resize;
}

.resize-handle-br {
    bottom: -10px;
    right: -10px;
    cursor: nwse-resize;
}

/* Guide Edit Toolbar */
.guide-edit-toolbar {
    position: absolute;
    bottom: calc(env(safe-area-inset-bottom, 16px) + 200px);
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 8px;
    background: rgba(0,0,0,0.8);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 8px 12px;
    border-radius: 24px;
    z-index: 20;
}

.guide-edit-toolbar.hidden {
    display: none;
}

.guide-edit-toolbar button {
    background: transparent;
    border: none;
    color: #fff;
    padding: 8px 16px;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    border-radius: 16px;
    transition: all 0.2s ease;
}

.guide-edit-toolbar button:active {
    background: rgba(255,255,255,0.1);
}

.guide-edit-toolbar button.primary {
    background: #34c759;
}

/* Landscape Mode */
@media (orientation: landscape) {
    .top-bar {
        padding-left: calc(env(safe-area-inset-left, 8px) + 8px);
        padding-right: calc(env(safe-area-inset-right, 8px) + 8px);
    }

    .bottom-controls {
        position: absolute;
        right: 0;
        top: 0;
        bottom: 0;
        left: auto;
        width: auto;
        padding: 16px;
        padding-right: calc(env(safe-area-inset-right, 16px) + 16px);
        flex-direction: column;
        justify-content: center;
        background: linear-gradient(270deg, rgba(0,0,0,0.6) 0%, transparent 100%);
    }

    .guide-selector {
        flex-direction: column;
        gap: 4px;
    }

    .guide-option {
        padding: 6px 12px;
        flex-direction: row;
        gap: 6px;
    }

    .guide-icon {
        font-size: 16px;
    }

    .guide-label {
        font-size: 11px;
    }

    .capture-area {
        flex-direction: column;
        gap: 20px;
    }

    .capture-btn {
        width: 64px;
        height: 64px;
    }

    .capture-btn-inner {
        width: 50px;
        height: 50px;
    }

    .timer-selector {
        flex-direction: column;
        gap: 2px;
    }

    .timer-option {
        padding: 6px 12px;
        font-size: 11px;
    }

    .ratio-panel {
        top: 50%;
        left: calc(env(safe-area-inset-left, 12px) + 60px);
        transform: translateY(-50%);
        flex-direction: column;
    }

    .ratio-panel.hidden {
        transform: translateY(-50%) translateX(-10px);
    }

    .settings-panel {
        width: 300px;
        max-width: 50%;
    }

    .preview-controls {
        flex-direction: column;
        right: 0;
        top: 50%;
        bottom: auto;
        left: auto;
        transform: translateY(-50%);
        padding-right: calc(env(safe-area-inset-right, 20px) + 20px);
        background: none;
    }

    .gallery-grid {
        grid-template-columns: repeat(4, 1fr);
    }
}

/* Grid Overlay - Positioned within ratio area */
.grid-overlay {
    position: absolute;
    pointer-events: none;
    z-index: 5;
    top: var(--grid-top, 0);
    left: var(--grid-left, 0);
    right: var(--grid-right, 0);
    bottom: var(--grid-bottom, 0);
}

.grid-overlay.hidden {
    display: none;
}

/* Guide Detection States */
/* 사람이 감지되었을 때 - 노란색 */
.guide-frame.detected .guide-silhouette {
    border-color: #ffd60a !important;
    border-style: solid !important;
    box-shadow: 0 0 15px rgba(255, 214, 10, 0.4);
}

/* 사람이 가이드 안에 부분적으로 들어왔을 때 - 주황색 */
.guide-frame.partial .guide-silhouette {
    border-color: #ff9500 !important;
    border-style: solid !important;
    box-shadow: 0 0 20px rgba(255, 149, 0, 0.5);
}

/* Perfect Alignment Feedback - 완벽하게 맞았을 때 - 초록색 */
.guide-frame.perfect .guide-silhouette {
    border-color: #34c759 !important;
    border-style: solid !important;
    box-shadow: 0 0 30px rgba(52, 199, 89, 0.5);
    animation: perfectPulse 1s ease-in-out infinite;
}

@keyframes perfectPulse {
    0%, 100% { box-shadow: 0 0 20px rgba(52, 199, 89, 0.4); }
    50% { box-shadow: 0 0 40px rgba(52, 199, 89, 0.7); }
}

.capture-btn.ready {
    animation: captureReady 0.8s ease-in-out infinite;
}

.capture-btn.ready .capture-btn-inner {
    background: #34c759;
}

@keyframes captureReady {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.08); }
}

/* Ready to shoot indicator */
.shoot-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    z-index: 50;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.shoot-indicator.visible {
    opacity: 1;
}

.shoot-indicator-ring {
    width: 120px;
    height: 120px;
    border: 4px solid #34c759;
    border-radius: 50%;
    animation: ringPulse 1.5s ease-in-out infinite;
}

@keyframes ringPulse {
    0% { transform: scale(0.8); opacity: 1; }
    100% { transform: scale(1.5); opacity: 0; }
}

.shoot-indicator-text {
    position: absolute;
    bottom: -40px;
    left: 50%;
    transform: translateX(-50%);
    background: #34c759;
    color: #fff;
    padding: 8px 20px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: 600;
    white-space: nowrap;
}
